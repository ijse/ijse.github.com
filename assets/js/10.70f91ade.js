(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{342:function(v,_,t){"use strict";t.r(_);var p=t(25),n=Object(p.a)({},function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("下文中C代表Ctrl，M代表Alt。\nC-a C-e 光标快速移动到行首,行尾")]),v._v(" "),t("p",[v._v("C-f C-b 向前,向后移动一个字符(前也就是右,后也就是左)")]),v._v(" "),t("p",[v._v("M-f M-b 向前,向后移动一个单词")]),v._v(" "),t("p",[v._v("C-d C-h 向前,向后删除一个字符")]),v._v(" "),t("p",[v._v("M-d C-w 向前,向后删除一个单词")]),v._v(" "),t("p",[v._v("C-u 删除光标字符到行首(这个东东当你输入密码错误的时候就很管用了的)")]),v._v(" "),t("p",[v._v("C-k 删除光标字符到行尾")]),v._v(" "),t("p",[v._v("C-t 交换光标所在字符和它左边的字符并跳转到下一个字符(像我这样指法不标准的经常会把字符打错位置可以试试哈)")]),v._v(" "),t("p",[v._v("M-t 和上面相似,只不过交换的是一个单词")]),v._v(" "),t("p",[v._v("M-c 把光标所在处的字符改为大写,然后跳到下一个单词的词首")]),v._v(" "),t("p",[v._v("M-l 把光标所在处字符到单词结束的字符都改为小写")]),v._v(" "),t("p",[v._v("M-u 把光标所在处字符到单词结束的字符都改为大写")]),v._v(" "),t("p",[v._v("C-/ 可以撤销对命令的修改(undo)")]),v._v(" "),t("p",[v._v("C-xx 可以在光标所在位置和行首来回切换")]),v._v(" "),t("p",[v._v("C-p C-n 查阅命令历史,类似方向上下键")]),v._v(" "),t("p",[v._v("C-r 这个算是我最喜欢的命令了,可以查看命令历史,找到前面执行过的命令.(这个不太好描述,谁用谁知道,用了自然就不会再像之前用history|grep xxx找到之后再!nnn来执行了),当搜索到想要的命令时,直接Enter就可以运行；你也可以用C-j,搜索到的命令就会放到命令行中,进行你想要的编辑之后再运行；C-g退出刚才的C-r模式.")]),v._v(" "),t("p",[v._v("M-. 输出上次命令的最后一个参数(可能没说太清楚,举个例子)")]),v._v(" "),t("p",[v._v("这里发现cd到一个文档错了,下次你就输入cat,再按M-.就会自动把后面的/etc/passwd补充上了的.")]),v._v(" "),t("p",[v._v("[benbenbear@wanghs ~]$ cd /etc/passwd\n-bash: cd: /etc/passwd: Not a directory\n[benbenbear@wanghs ~]$ cat /etc/passwd")]),v._v(" "),t("p",[v._v("C-M-y 同上,也是输出上次命令的最后一个参数")])])},[],!1,null,null,null);_.default=n.exports}}]);
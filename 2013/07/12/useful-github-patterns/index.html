<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一些常见的GITHUB模式 | &lt;ijse blog /&gt;</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.8f3ff9cb.css" as="style"><link rel="preload" href="/assets/js/app.ec7fea01.js" as="script"><link rel="preload" href="/assets/js/2.e517e879.js" as="script"><link rel="preload" href="/assets/js/8.669a198a.js" as="script"><link rel="prefetch" href="/assets/js/10.f9913c3a.js"><link rel="prefetch" href="/assets/js/11.95851e16.js"><link rel="prefetch" href="/assets/js/12.43e2dda2.js"><link rel="prefetch" href="/assets/js/13.da0bede2.js"><link rel="prefetch" href="/assets/js/14.79da67a5.js"><link rel="prefetch" href="/assets/js/15.68bb74db.js"><link rel="prefetch" href="/assets/js/16.49e32c58.js"><link rel="prefetch" href="/assets/js/17.1bb4b8a1.js"><link rel="prefetch" href="/assets/js/18.bd49a380.js"><link rel="prefetch" href="/assets/js/19.e2f7c3c7.js"><link rel="prefetch" href="/assets/js/20.4ff88139.js"><link rel="prefetch" href="/assets/js/21.2dc86536.js"><link rel="prefetch" href="/assets/js/22.b9918fc6.js"><link rel="prefetch" href="/assets/js/23.d0c1de78.js"><link rel="prefetch" href="/assets/js/24.012e7fd8.js"><link rel="prefetch" href="/assets/js/25.0f8121fa.js"><link rel="prefetch" href="/assets/js/26.a111cb24.js"><link rel="prefetch" href="/assets/js/27.c298ea6b.js"><link rel="prefetch" href="/assets/js/28.0006075a.js"><link rel="prefetch" href="/assets/js/29.78ae6ae7.js"><link rel="prefetch" href="/assets/js/3.fd4fe1a3.js"><link rel="prefetch" href="/assets/js/30.e4764ad9.js"><link rel="prefetch" href="/assets/js/31.7982c8a4.js"><link rel="prefetch" href="/assets/js/32.8ff2b221.js"><link rel="prefetch" href="/assets/js/33.fd3837bc.js"><link rel="prefetch" href="/assets/js/34.2dfb2d55.js"><link rel="prefetch" href="/assets/js/35.ea7e42d5.js"><link rel="prefetch" href="/assets/js/36.297c0cd8.js"><link rel="prefetch" href="/assets/js/37.89c1c8ad.js"><link rel="prefetch" href="/assets/js/38.5327d57b.js"><link rel="prefetch" href="/assets/js/39.b89a9c8b.js"><link rel="prefetch" href="/assets/js/4.1869312e.js"><link rel="prefetch" href="/assets/js/5.b99b3b54.js"><link rel="prefetch" href="/assets/js/6.dfa135f3.js"><link rel="prefetch" href="/assets/js/7.f1b91bdc.js"><link rel="prefetch" href="/assets/js/9.cec6073e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8f3ff9cb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container vuepress-theme-simple"><header class="header"><a href="/" title="" class="router-link-active">
      &lt;ijse blog /&gt;
    </a> <div style="clear: both"></div></header> <section class="post-view"><h1 class="post-title">
    一些常见的GITHUB模式
    <time datetime="2013-7-12" title="2013-7-12" pubdate="pubdate" class="post-date">
  5 years ago
</time></h1> <div class="content default"><p>source: <a href="">http://blog.quickpeople.co.uk/2013/07/10/useful-github-patterns/</a></p> <p><strong>PR: pull request</strong></p> <h3 id="_1-the-peel-off-pr"><a href="#_1-the-peel-off-pr" aria-hidden="true" class="header-anchor">#</a> 1. the peel-off PR</h3> <p>场景：</p> <pre><code> * 我正在feature branch上编码
 * 我看到一些有问题的代码，想马上修复，但这些修改与我当前所做的feature完全无关（例如：一些小BUG，代码风格不一致等）
</code></pre> <p>措施：</p> <pre><code> * 暂停正在做的工作（commit或stash）
 * checkout master
 * 创建一个新的branch
 * 修正问题，创建一个PR
 * 切换回feature branch，继续工作
 * 最后，与feature分支合并
</code></pre> <p>这既可以立即修复无关问题，又可以保证feature branch干净。</p> <h3 id="_2-the-optimistic-branch"><a href="#_2-the-optimistic-branch" aria-hidden="true" class="header-anchor">#</a> 2. the optimistic branch</h3> <p>场景：</p> <pre><code> * 有一个未合并的分支（branch-A），暂时不能被合并（例如 CI不通过，代码审查太忙等等）
 * 我需要修改与branch-A相关的代码
</code></pre> <p>措施：</p> <pre><code> * 基于branch-A创建一个新的分支branch-B
 * 当branch-A合并到master分支后，我将branch-B分支rebase到master分支上，并解决合并冲突
 * branch-A上之后的bugfixes也会合并到branch-B上
</code></pre> <p>如果branch-A上的修改很大，这种措施可能会带来一些代码冲突，但是乐观上来看，在95%情况下是没问题的。</p> <h3 id="_3-the-heads-up-pr"><a href="#_3-the-heads-up-pr" aria-hidden="true" class="header-anchor">#</a> 3 the heads-up PR</h3> <p>场景：</p> <pre><code> * 我正在做一些不需要代码审查的修改
 * 但我仍然希望别人知道
</code></pre> <p>措施：</p> <pre><code> * 在分支上开发
 * 创建一个PR
 * 然后自己将PR合并
</code></pre> <p>这种方法并没有影响我自己，但GitHub仍然会向其它人发Email通知PR，因此其它人仍然可以对代码评论。</p> <h3 id="_4-the-sneaky-commit"><a href="#_4-the-sneaky-commit" aria-hidden="true" class="header-anchor">#</a> 4. the sneaky commit</h3> <p>场景：</p> <pre><code> * 代码已经经过审查并且合并到了master分支上
 * 我需要做些小修改，这些修改不值得通知其它人
</code></pre> <p>措施：</p> <pre><code> * 直接将代码提交到master分支上
</code></pre> <h3 id="_5-the-roger-roger-comment"><a href="#_5-the-roger-roger-comment" aria-hidden="true" class="header-anchor">#</a> 5. the roger roger comment</h3> <p>场景：</p> <pre><code> * 在分支的代码审查时，我收到一些不好的反馈
 * 我需要基于反馈来进行问题修复
</code></pre> <p>措施：</p> <pre><code> * 我对这个PR创建一个评论，里面注明修复commit的ref
 * GitHub会自动将评论中的ref转换为diff的链接地址，因此我的同事会：
      * 收到邮件通知
      * 点击链接地址，查看修改
      * 然后知道可以继续审查代码
</code></pre> <h3 id="_6-the-creepin-commit"><a href="#_6-the-creepin-commit" aria-hidden="true" class="header-anchor">#</a> 6. the creepin' commit</h3> <p>场景：</p> <pre><code> * 我发现一些很小的代码格式问题（如 不必要的空格，文件末尾缺少空白行等等）
 * 一段代码的修改应该属于上一次提交
 * 我的代码不应该commit（例如 不能通过测试）但我仍然希望能够回滚到这里，以便安全地做些实验
</code></pre> <p>措施：</p> <pre><code> * 对前两种情况，我直接修正(amend)上一次提交
 * 对第三种情况，我创建一个开发提交(work-in-progress commit), 然后开发时对这个分支进行不断修改，直到满足提交的要求。
</code></pre> <h3 id="_7-the-forced-branch"><a href="#_7-the-forced-branch" aria-hidden="true" class="header-anchor">#</a> 7. the forced branch</h3> <p>场景：</p> <pre><code> * 我需要修改一个远程库里的分支，例如：我在一次提交注释中措辞不当。
</code></pre> <p>措施：</p> <pre><code> * 我在本地修改这次提交
 * 然后强制推送到远程库的分支上
</code></pre> <p>尽管强制推送到远程库这种做法很不推荐，但我的经验是：在这种情况下，很少会出问题（只要它只针对分支，而非master分支）。GitHub会自动解决好强制推送到分支的问题，例如不会丢失之前提交的注释等等。</p> <h3 id="_8-the-reformat-peel-off"><a href="#_8-the-reformat-peel-off" aria-hidden="true" class="header-anchor">#</a> 8. the reformat peel-off</h3> <p>场景：</p> <pre><code> * 我需要修改和重新格式化些代码
</code></pre> <p>措施：</p> <pre><code> * 我向master分支上单独做次只包含重新格式化修改的commit
 * 我将分支rebase到master上
</code></pre> <p>用这种方式，分支上的修改做起对比来会显得非常干净整洁，很有利于代码审查，因为它不会包含重新格式化修改。</p> <h3 id="_9-the-prototype-pr"><a href="#_9-the-prototype-pr" aria-hidden="true" class="header-anchor">#</a> 9. the prototype PR</h3> <p>场景：</p> <pre><code> 我在代码完全实现前想得到更多的反馈
</code></pre> <p>措施：</p> <pre><code> * 我在一条分支上做些hack
 * 我发起一个PR，这个PR并不是要提交代码，而是发起一个讨论
 * 当得到讨论结果后，关闭这个PR（并删除分支）
 * 我创建另一个分支和PR
</code></pre> <p>我曾经以为PR只是当代码完成时对代码进行提交，现在我深刻理解了“<a href="https://github.com/blog/1124-how-we-use-pull-requests-to-build-github" target="_blank" rel="noopener noreferrer">Pull request are a great way to start a conversation<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>&quot; - GitHub围绕PR相关的功能（比如 代码行评论，回复，通知和比较）非常有利于编码及设计讨论，而且可以防止开发者走进死胡同。</p></div> <!----></section> <footer class="footer"><!----></footer></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ec7fea01.js" defer></script><script src="/assets/js/2.e517e879.js" defer></script><script src="/assets/js/8.669a198a.js" defer></script>
  </body>
</html>
